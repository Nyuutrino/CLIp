/*

    Code provided by Nyuutrino (https://replit.com/@Nyuutrino).

*/

/*
  License (MIT) - see LICENSE file in main on the github page
  
*/

const CLIp={};(()=>{"use strict";class e extends Error{constructor(e,...t){super(e,...t),this.name="RuntimeError",this.message="(CLIp runtime-evaluator): "+e}}class t extends Error{constructor(e,...t){super(e,...t),this.name="ParsetimeError",this.message="(CLIp parser): "+e}}class n extends Error{constructor(e,...t){super(e,...t),this.name="InitializationError",this.message="(CLIp Initializer): "+e}}class r extends Error{constructor(e,...t){super(e,...t),this.name="NameError",this.message="(CLIp name-checker): "+e}}CLIp.CompiletimeError=class extends Error{constructor(e,...t){super(e,...t),this.name="CompiletimeError",this.message="(CLIp compile-time parser): "+e}},CLIp.RuntimeError=e,CLIp.ParsetimeError=t,CLIp.InitializationError=n,CLIp.NameError=r;let o=null;const a={executionMode:{value:"readWrite",allowedValues:["writeOnly","readOnly","readWrite"]},strictMode:!1,strictCommandMode:!1},i=["string","number","null","undefined","NaN","infer"];Object.freeze(a.allowedValues);const l={type:{name:"_CLIpObjectletType",inCommanders:!0,inAllCommandlets:!0,inProperties:!0,inMethods:!0,type:"string"},value:{name:"_CLIpObjectletValue",inCommanders:!1,inAllCommandlets:!0,inProperties:!0,inMethods:!0,type:"any"},propertyAccessibility:{name:"_CLIpObjectletPropertyAccessibility",inCommanders:!1,inAllCommandlets:!1,inProperties:!0,inMethods:!1,type:"string"},allowedValues:{name:"_CLIpObjectletAllowedValues",inCommanders:!1,inAllCommandlets:!1,inProperties:!0,inMethods:!1,type:"array"},allowedTypes:{name:"_CLIPObjectletAllowedTypes",inCommanders:!1,inAllCommandlets:!1,inProperties:!0,inMethods:!1,type:"array"},allowListeners:{name:"_CLIpObjectletAllowListeners",inCommanders:!1,inAllCommandlets:!0,inProperties:!0,inMethods:!0,type:"boolean"},listeners:{name:"_CLIpListenersArray",inCommanders:!1,inAllCommandlets:!0,inProperties:!0,inMethods:!0,type:"array"},setter:{name:"_CLIpObjectletSetter",inCommanders:!1,inAllCommandlets:!0,inProperties:!0,inMethods:!0,type:"function"},locked:{name:"_CLIpCommandletLocked",inCommanders:!1,inAllCommandlets:!0,inProperties:!0,inMethods:!0,type:"boolean"},sealed:{name:"_CLIpCommanderSealed",inCommanders:!0,inAllCommandlets:!1,inProperties:!1,inMethods:!1,type:"boolean"},MetaTypeMatches:(e,t)=>{if(void 0===e)throw new TypeError('Parameter "itemKey" (argument 1) is not defined.');if(void 0===t)throw new TypeError('Parameter "value" (argument 2) is not defined.');if("string"!=typeof e)throw new TypeError(`Parameter "itemKey" (argument 1) is not a string representing the key of the object that could potentially be a metadata name. Expected string type found a type of "${typeof e}" instead with a value of "${e}".`);const n={any:()=>!0,string:e=>"string"==typeof e,boolean:e=>"boolean"==typeof e,function:e=>"function"==typeof e,array:e=>Array.isArray(e)};return!!Object.entries(n).filter(n=>n[1](t)&&Object.entries(l).find(t=>t[1].name===e&&t[1].type===n[0])).length}};{const e=e=>e.map(e=>({Name:e[1].name,ShortName:e[0],Type:e[1].type}));Object.defineProperties(l,{CommanderMeta:{get:()=>e(Object.entries(l).filter(e=>e[1].inCommanders)||[])},CommandletMeta:{get:()=>e(Object.entries(l).filter(e=>e[1].inAllCommandlets||e[1].inProperties||e[1].inMethods)||[])},PropertyMethodMeta:{get:()=>e(Object.entries(l).filter(e=>e[1].inProperties&&e[1].inMethods)||[])},PropertyMeta:{get:()=>e(Object.entries(l).filter(e=>e[1].inProperties)||[])},MethodMeta:{get:()=>e(Object.entries(l).filter(e=>e[1].inMethods)||[])}})}for(const e in l)Object.freeze(l[e]);Object.freeze(l);const s=e=>e.replace(/[-[\]{}()*+?.,\\^$|#\s]/g,"\\$&"),p=(e,t)=>{if(null===o)throw new n("Root is not initialized.");if(t){if("object"!=typeof e)return;if(e[l.locked]||e[l.sealed])throw new n("Cannot mutate a locked commandlet/sealed commander.")}},m=e=>{if(void 0===e)throw new TypeError('Parameter "propertyName" (argument 1) is not defined.');if("string"!=typeof e)throw new TypeError(`Parameter "propertyName" (argument 1) is not of type "string". Expected string found "${e}" instead with type "${typeof e}".`);const t="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890_".split("");e=(e=>{try{e=e.toString()}catch(e){throw new TypeError("The argument passed in is not a valid string and/or cannot be converted to a string type.")}return[...e]})(e);let n=!1;return e.forEach(e=>{t.filter(t=>t===e).length<1&&(n=!0)}),!n};class c{constructor(){this.T_ESCAPE,this.T_STRING,this.T_POINTERSTART,this.T_POINTEREND,this.T_SETTERSTART,this.T_SETTEREND,this.T_ARGUMENTSEPARATOR,this.T_TYPEDECLSTART,this.T_TYPEDECLEND,this.T_LEGALCHARS="",this.IS_SETTER,this.SETTER_FOUND,this.POINTER_FOUND,this.IS_POINTER,this.IS_STRING,this.LAST_OPERATOR,this.IS_ESCAPE=!1,this.TYPE_DECL_OPEN=!1,this.COL=0,this.INPUT=""}InitializeTokens(e,t,n,r,o,a,i,l,s,p){if(arguments.length<10)throw new TypeError(`Failed to execute "InitializeTokens", 10 arguments are required but only ${arguments.length} present.`);let m=0;for(let e in arguments)if(++m,"string"!=typeof arguments[e])throw new TypeError(`Argument number ${m+1} is not of string type.`);this.T_ESCAPE=e,this.T_STRING=t,this.T_POINTERSTART=n,this.T_POINTEREND=r,this.T_SETTERSTART=o,this.T_SETTEREND=a,this.T_ARGUMENTSEPARATOR=i,this.T_TYPEDECLSTART=l,this.T_TYPEDECLEND=s,this.T_LEGALCHARS=p}Parse(e,t=!1,n=!1){if(arguments.length<1)throw new TypeError('Failed to execute "Parse", 1 argument required but only 0 present.');if("string"!=typeof e)throw new TypeError("Argument 1 passed in is not of string type.");const{T_ESCAPE:r,T_STRING:o,T_POINTERSTART:a,T_POINTEREND:i,T_SETTERSTART:l,T_SETTEREND:s,T_ARGUMENTSEPARATOR:p,T_LEGALCHARS:m,T_TYPEDECLSTART:c,T_TYPEDECLEND:u}=this;let{IS_SETTER:d,SETTER_FOUND:y,POINTER_FOUND:h,IS_POINTER:f,IS_STRING:b,LAST_OPERATOR:w,IS_ESCAPE:g,COL:v,TYPE_DECL_OPEN:E}=this;const C=[],T=[],j=[],P=[];let _=0,L=0,O=0,A=0,I=0,S=!1;n||(S=!0);const N=()=>{S&&L>0?C.push({type:"objectlet",column_numbers:[L,O],value:j.splice(0).join("")}):j.splice(0),L=0,O=0};for(let n=0;n<e.length;++n){++v;const k=e[n];if(I>0&&(S=!0),w=void 0===e[n-1]?"":e[n-1],g){if(b&&k===o){T.push(k),g=!1;continue}if(b){T.push(`\\${k}`),g=!1;continue}S&&C.push({type:"escaped_char",column_numbers:[v-1,v],value:`\\${k}`}),g=!1}else if(k!==r||g||b)if(k!==r||g){if(k===o&&!b&&!E){O=v-1,N(),b=!0,_=v;continue}if(k!==o||!b||E){if(b){T.push(k);continue}if(k!==a||f||E){if(k===i&&f&&w===a){S&&C.push({type:"pointer",column_numbers:[v-1,v],value:a+i}),h=!0,f=!1;continue}if(k!==l||d){if(k===s&&d&&w===l){if(S&&C.push({type:"setter",column_numbers:[v-1,v],value:l+s}),d=!1,y=!0,++I,t)break;continue}if(k!==p||d||f){if(k!==c||b||d||f){if(k!==u||b||d||f){if(E){P.push(k);continue}if(k===o&&!b&&E){b=!0;continue}if(k===o&&b&&E){b=!1,P.push(T.splice(0).join(""));continue}if(b&&E){T.push(k);continue}if(E){P.push(k);continue}if(m.split("").filter(e=>e===k).length>0&&!f&&!d&&!E){0===L&&j.length<1&&(L=v),j.push(k);continue}if(d){d=!1,O=v-1,N(),S&&C.push({type:"unknown_token",column_numbers:[v-1,v],value:e[n-1]+k});continue}if(f){f=!1,O=v-1,N(),S&&C.push({type:"unknown_token",column_numbers:[v-1,v],value:e[n-1]+k});continue}O=v-1,N(),S&&C.push({type:"unknown_token",column_numbers:[v,v],value:k});continue}E?(E=!1,C.push({type:"behavior_block",column_numbers:[A,v],value:`${c}${P.splice(0).join("")}${u}`}),A=0):C.push({type:"close_behavior_block_failure",column_numbers:[v,v],value:k});continue}O=v-1,N(),E?C.push({type:"open_behavior_block_failure",column_numbers:[v,v],value:k}):(E=!0,A=v);continue}O=v-1,N(),S&&C.push({type:"argument_separator",column_numbers:[v,v],value:p});continue}O=v-1,N(),y=!1,d=!0;continue}O=v-1,N(),h=!1,f=!0;continue}{const e=T.splice(0);S&&C.push({type:"string",column_numbers:[_,v],value:e.join("")}),b=!1}}else g=!0;else g=!0,N()}return f?C.push({type:"unknown_token",column_numbers:[v,v],value:e[e.length-1]}):d&&C.push({type:"unknown_token",column_numbers:[v,v],value:e[e.length-1]}),j.length>0&&(O=v,N()),b?C.push({type:"unclosed_string",column_numbers:[_,v],value:T.join("")}):E&&C.push({type:"unclosed_behavior_block",column_numbers:[A,v],value:P.join("")}),C}}CLIp.InitializeRoot=(()=>{if(null!==o)throw new n("Root cannot be initialized twice");(o={})[l.type.name]="property-container",Object.defineProperty(o,"CLIp",{value:{[l.type.name]:"clip-help"},enumerable:!0});const e=o.CLIp;Object.defineProperties(e,{About:{value:{[l.type.name]:"property",[l.allowedValues.name]:[],[l.propertyAccessibility.name]:"read-only",[l.allowListeners.name]:!1,[l.locked.name]:!0,[l.listeners.name]:[],[l.value.name]:'CLIp (Stands for "CLI parser", pronounced "Clype") is a command line interpreter that is programmed in JavaScript. It allows functionality for creating a terminal-like interface for applications (especially online games). CLIp is built by Nyuutrino, so check him out (https://replit.com/@Nyuutrino)!'},enumerable:!0},StrictModeEnabled:{value:{[l.type.name]:"method",[l.allowListeners.name]:!1,[l.listeners.name]:[],[l.locked.name]:!0,[l.value.name]:()=>a.strictMode},enumerable:!0},StrictCommandModeEnabled:{value:{[l.type.name]:"method",[l.allowListeners.name]:!1,[l.listeners.name]:[],[l.locked.name]:!0,[l.value.name]:()=>a.strictCommandMode},enumerable:!0},ExecutionMode:{value:{[l.type.name]:"method",[l.allowListeners.name]:!1,[l.listeners.name]:[],[l.locked.name]:!0,[l.value.name]:()=>a.executionMode.value},enumerable:!0},VERSION:{value:{[l.type.name]:"property",[l.allowedValues.name]:[],[l.allowedTypes.name]:[],[l.propertyAccessibility.name]:"read-only",[l.allowListeners.name]:!1,[l.listeners.name]:[],[l.locked.name]:!0,[l.value.name]:"1.1.0"},enumerable:!0}});return(e=>{const t=e=>{const n=()=>{Object.freeze(e)};for(let r in e)"[object Object]"===Object.prototype.toString.call(e[r])?(n(),t(e[r])):n()};t(e),Object.freeze(e)})(o.CLIp),o}),CLIp.ChangeExecutionMode=(e=>{if(!a.executionMode.allowedValues.includes(e))throw new n(`Unrecognized execution mode "${e}". Accepted types are: "${a.executionMode.allowedValues}".`);return a.executionMode.value=e,a.executionMode.value}),CLIp.EnableStrictMode=(()=>{p(),a.strictMode=!0}),CLIp.DisableStrictMode=(()=>{p(),a.strictMode=!1}),CLIp.EnableStrictCommandMode=(()=>{p(),a.strictCommandMode=!0}),CLIp.DisableStrictCommandMode=(()=>{p(),a.strictCommandMode=!1}),CLIp.DefineMainObject=((e,t)=>{if(p(e,!0),void 0===e)throw new TypeError('Parameter "mainObject" (argument 1) is not defined.');if("string"!=typeof e)throw new TypeError('Parameter "mainObject" (argument 1) must be a string containing the name of the main object.');if(void 0!==t&&"boolean"!=typeof t)throw new TypeError('Parameter "reConfigurable" (argument 2) is set but not of type "boolean".');if(Object.entries(l).find(t=>t[1].name===e))throw new r("Naming collision with the metadata of objectlets.");if(!m(e)){if(a.strictMode)throw new r(`Main object name "${e}" has an illegal character. Legal characters are lower-case and upper-case alphabet letters and numbers.`);console.warn(`(CLIp name-checker): Main object name "${e}" has an illegal character (this will mess with user accessibility). Legal characters are lower-case and upper-case alphabet letters and numbers.`)}if(void 0===t&&(t=!1),o[e])try{Object.defineProperty(o,e,{value:{[l.type.name]:"main-object"},enumerable:!0,configurable:!0})}catch(e){if(a.strictMode)throw new TypeError("Attempted to re-define a main property container that is not configured to do so.")}else Object.defineProperty(o,e,{value:{[l.type.name]:"main-object"},enumerable:!0,configurable:t});return o[e]}),CLIp.BindPropertyContainer=((e,t,n)=>{if(void 0===e)throw new TypeError('Paramter "object" (argument 1) is not defined.');if(void 0===t)throw new TypeError('Parameter "objectName" (argument 2) is not defined.');if("object"!=typeof e&&("property-container"!==e[l.type.name]||"main-object"!==e[l.type.name]))throw new TypeError('Parameter "object" (argument 1) is not a valid commander.');if("string"!=typeof t)throw new TypeError('Parameter "objectName" (argument 2) is not of type "string".');if(void 0!==n&&"boolean"!=typeof n)throw new TypeError('Parameter "reConfigurable" (argument 3) is set but not of type "boolean".');if(Object.entries(l).find(e=>e[1].name===t))throw new r("Naming collision with the metadata of objectlets.");if(!m(t)){if(a.strictMode)throw new r(`Property container name "${t}" has an illegal character. Legal characters are lower-case and upper-case alphabet letters and numbers.`);console.warn(`(CLIp name-checker): Property container name "${t}" has an illegal character (this will mess with user accessibility). Legal characters are lower-case and upper-case alphabet letters and numbers.`)}if(void 0===n&&(n=!1),e[t])try{Object.defineProperty(e,t,{value:{[l.type.name]:"property-container"},enumerable:!0,configurable:!0})}catch(e){if(a.strictMode)throw new TypeError("Attempted to re-define a property container that is not configured to do so.")}else Object.defineProperty(e,t,{value:{[l.type.name]:"property-container"},enumerable:!0,configurable:n});return e[t]}),CLIp.BindProperty=((e,t,n,o)=>{if(p(e,!0),void 0===e)throw new TypeError('Paramter "propertyContainer" (argument 1) is not defined.');if(void 0===t)throw new TypeError('Parameter "propertyArray" (argument 2) is not defined.');if("[object Object]"!==Object.prototype.toString.call(e)&&("property-container"!==e[l.type.name]||"main-object"!==e[l.type.name]))throw new TypeError('Parameter "propertyContainer" (argument 2) is not a valid commander to bind the property to.');if("[object Array]"!==Object.prototype.toString.call(t))throw new TypeError('Paramter "propertyArray" (argument 2) is not a valid array with values containing the name of the property of type "string" and the value.');if("string"!=typeof t[0])throw new TypeError('Paramter "propertyArray" (argument 2) is not a valid array with values containing the name of the property of type "string" and the value.');if("[object Object]"===Object.prototype.toString.call(t[1]))throw new TypeError('The value cannot be an object. Try using "CLIp.BindPropertyContainer()" instead.');if(void 0!==t[2]&&"string"!=typeof t[2])throw new TypeError('Parameter "propertyArray" (argument 2) has the property-access value passed in but is not of type "string" representing the values "read-only" or "read-write".');if(void 0!==n&&"boolean"!=typeof n)throw new TypeError('Parameter "listenersAllowed" (arugment 3) is set but not of type "boolean".');if("read-only"!==t[2]&&"read-write"!==t[2]&&void 0!==t[2])throw new TypeError(`Parameter "propertyArray" (argument 2) has the property-access value passed in but is not a string containing the values "read-only" or "read-write". Instead found a value of type "${typeof t[2]}" and a value of "${t[2]}".`);if(void 0!==o&&"boolean"!=typeof o)throw new TypeError('Parameter "reConfigurable" (argument 4) is set but not of type "boolean".');if(Object.entries(l).find(e=>e[1].name===t[0]))throw new r("Naming collision with the metadata of objectlets.");if(void 0===t[2]&&(t[2]="read-write"),!m(t[0])){if(a.strictMode)throw new r(`Property name "${t[0]}" has an illegal character. Legal characters are lower-case and upper-case alphabet letters and numbers.`);console.warn(`(CLIp name-checker): Property name "${t[0]}" has an illegal character (this will mess with user accessibility). Legal characters are lower-case and upper-case alphabet letters and numbers.`)}if(void 0===o&&(o=!1),e[t[0]])try{n?(Object.defineProperty(e,t[0].toString(),{value:{[l.type.name]:"property",[l.value.name]:t[1],[l.allowedValues.name]:[],[l.allowedTypes.name]:[],[l.propertyAccessibility.name]:t[2],[l.allowListeners.name]:!0,[l.listeners.name]:[]},enumerable:!0,configurable:o}),Object.defineProperty(e[t[0]],l.setter.name,{configurable:!0,enumerable:!0,set:function(e){const t=this[l.value.name];let n;try{this[l.value.name]=e}catch(e){n=e}this[l.listeners.name].forEach(r=>{r(this[l.type.name],e,t,n)})}})):Object.defineProperty(e,t[0].toString(),{value:{[l.type.name]:"property",[l.value.name]:t[1],[l.allowedValues.name]:[],[l.allowedTypes.name]:[],[l.propertyAccessibility.name]:t[2],[l.allowListeners.name]:!1},enumerable:!0,configurable:o})}catch(e){if(a.strictMode)throw new TypeError("Attempted to re-define a property that is not configured to do so.")}else n?(Object.defineProperty(e,t[0].toString(),{value:{[l.type.name]:"property",[l.value.name]:t[1],[l.allowedValues.name]:[],[l.allowedTypes.name]:[],[l.propertyAccessibility.name]:t[2],[l.allowListeners.name]:!0,[l.listeners.name]:[]},enumerable:!0,configurable:o}),Object.defineProperty(e[t[0]],l.setter.name,{configurable:!0,enumerable:!0,set:function(e){const t=this[l.value.name];let n;try{this[l.value.name]=e}catch(e){n=e}this[l.listeners.name].forEach(r=>{r(this[l.type.name],e,t,n)})}})):Object.defineProperty(e,t[0].toString(),{value:{[l.type.name]:"property",[l.value.name]:t[1],[l.allowedValues.name]:[],[l.allowedTypes.name]:[],[l.propertyAccessibility.name]:t[2],[l.allowListeners.name]:!1},enumerable:!0,configurable:o});return e[t[0]]}),CLIp.BindMethod=((e,t,n,o)=>{if(p(e,!0),void 0===e)throw new TypeError('Paramter "propertyContainer" (argument 1) is not defined.');if(void 0===t)throw new TypeError('Parameter "methodArray" (argument 2) is not defined.');if("[object Object]"!==Object.prototype.toString.call(e)&&("property-container"!==e[l.type.name]||"main-object"!==e[l.type.name]))throw new TypeError('Parameter "propertyContainer" (argument 1) is not a valid commander to bind the property to.');if("string"!=typeof t[0])throw new TypeError('Paramter "methodArray" (argument 2) is not a valid array with values containing the name of the method of type "string" and the method of type "function".');if("function"!=typeof t[1])throw new TypeError('Paramter "methodArray" (argument 2) is not a valid array with values containing the name of the method of type "string" and the method of type "function".');if("string"!=typeof t[0])throw new TypeError('Paramter "methodArray" (argument 2) is not a valid array with values containing the name of the property of type "string" and the value.');if("object"==typeof t[1])throw new TypeError('The value cannot be an object. Try using "CLIp.BindPropertyContainer()" instead.');if(void 0!==n&&"boolean"!=typeof n)throw new TypeError('Parameter "listenersAllowed" (arugment 3) is set but not of type "boolean".');if(Object.entries(l).find(e=>e[1].name===t[0]))throw new r("Naming collision with the metadata of objectlets.");if(void 0!==o&&"boolean"!=typeof o)throw new TypeError('Parameter "reConfigurable" (argument 4) is set but not of type "boolean".');if(!m(t[0])){if(a.strictMode)throw new r(`Method name "${t[0]}" has an illegal character. Legal characters are lower-case and upper-case alphabet letters and numbers.`);console.warn(`(CLIp name-checker): Method name "${t[0]}" has an illegal character (this will mess with user accessibility). Legal characters are lower-case and upper-case alphabet letters and numbers.`)}if(void 0===o&&(o=!1),e[t[0]])try{n?(Object.defineProperty(e,t[0].toString(),{value:{[l.type.name]:"method",[l.allowListeners.name]:!0,[l.listeners.name]:[],[l.value.name]:t[1]},enumerable:!0,configurable:o}),Object.defineProperty(e[t[0]],l.setter.name,{enumerable:!0,configurable:!0,set:function(e){this[l.listeners.name].forEach(t=>{t(this[l.type.name],e)});const t=this[l.value.name](...e);e.push(t)}})):Object.defineProperty(e,t[0].toString(),{value:{[l.type.name]:"method",[l.allowListeners.name]:!1,[l.value.name]:t[1]},enumerable:!0,configurable:o})}catch(e){if(a.strictMode)throw new TypeError("Attempted to re-define a method that is not configured to do so.")}else n?(Object.defineProperty(e,t[0].toString(),{value:{[l.type.name]:"method",[l.allowListeners.name]:!0,[l.listeners.name]:[],[l.value.name]:t[1]},enumerable:!0,configurable:o}),Object.defineProperty(e[t[0]],l.setter.name,{enumerable:!0,configurable:!0,set:function(e){this[l.listeners.name].forEach(t=>{t(this[l.type.name],e)});const t=this[l.value.name](...e);e.push(t)}})):Object.defineProperty(e,t[0].toString(),{value:{[l.type.name]:"method",[l.allowListeners.name]:!1,[l.value.name]:t[1]},enumerable:!0,configurable:o});return e[t[0]]}),CLIp.ChangeObjectletAccessibility=((e,t)=>{if(p(e,!0),"object"!=typeof e&&!e[l.type.name])throw new TypeError('Parameter "objectlet" (argument 1) is not an objectlet that has a property accessiblity mode.');if("read-only"!==t&&"read-write"!==t)throw new n('Parameter "accessibility" (argument 2) is not a string with either the value "read-only" or read-write"');if(!e[l.propertyAccessibility.name])throw new n('Parameter "objectlet" (argument 1) is not set with a property accessibility mode.');e[l.propertyAccessibility.name]=t}),CLIp.LockCommandlet=(e=>{if(p(),"object"!=typeof e&&!e[l.type.name])throw new TypeError('Parameter "commandlet" (argument 1) is not an object and/or is not a valid commandlet.');if("main-object"===e[l.type.name]||"property-container"===e[l.type.name]||"clip-help"===e[l.type.name])throw new n('Cannot perform "CLIp.LockCommandlet" on a property container/main property container. Use "CLIp.SealCommander()" instead.');return e[l.locked.name]?e:(e[l.locked.name]=!0,Object.freeze(e),e)}),CLIp.SealCommander=(e=>{if(p(),"object"!=typeof e&&!e[l.type.name])throw new TypeError('Parameter "commandlet" (argument 1) is not an object and/or is not a valid commandlet.');if("main-object"!==e[l.type.name]&&"property-container"!==e[l.type.name]&&"clip-help"!==e[l.type.name])throw new n('Cannot perform CLIp.SealCommander on a commandlet. Use "CLIp.LockCommandlet()" instead.');return e[l.sealed.name]?e:(e[l.sealed.name]=!0,Object.freeze(e),e)}),CLIp.BindRestrictingValues=((e,t)=>{p(t,!0);const r=e=>{throw new n(`Parameter "values" (argument 1) contains an invalid value that is not an array or is an empty array at the ${e}th index. The value should be an array containing a single allowed value and an array containing the allowed types for that value.`)},o=i.reduce((e,t)=>e+`, ${t}`);if(!Array.isArray(e))throw new TypeError('Parameter "values" (argument 1) is not a valid array containing the allowed values and an array of their their types.');if("[object Object]"!==Object.prototype.toString.call(t))throw new TypeError('Parameter "objectlet" (argument 2) is not a valid object representing the objectlet to bind restrictive values to.');if(!t[l.allowedValues.name])throw new n("Objectlet does not provide access to an allowed values object rendering it not applicable for allowed values.");if("read-only"===t[l.propertyAccessibility.name])throw new n("Objectlet is read-only invalidating the ability to bind restricting values on.");if(e.forEach((e,t)=>{Array.isArray(e)||r(t),e[0]||r(t),e[1]||r(t),Array.isArray(e[1])&&e[1].length||r(t),e[1].forEach(e=>{if(i.filter(t=>t===e).length<1&&"all"!==e[1])throw new TypeError(`Invalid data type "${e[0]}". Allowed data types are: ${o} as well as "all".`)})}),!t[l.allowedValues.name])throw new n('Parameter "objectlet" (argument 2) is not a valid objectlet and/or is not capable of binding restricting values to.');t[l.allowedValues.name]=e}),CLIp.BindRestrictingTypes=((e,t)=>{p(t,!0);const r=i.reduce((e,t)=>e+`, ${t}`);if(!Array.isArray(e))throw new TypeError('Parameter "types" (argument 1) is not a valid array containing the allowed types and an optional object with a key of "default_type" and a value of the default type to convert to.');if("[object Object]"!==Object.prototype.toString.call(t))throw new TypeError('Parameter "objectlet" (argument 2) is not a valid object representing the objectlet to bind restrictive types to.');if(!t[l.allowedTypes.name])throw new n("Objectlet does not provide access to an allowed types object rendering it not applicable for allowed types.");if("read-only"===t[l.propertyAccessibility.name])throw new n("Objectlet is read-only invalidating the ability to bind restricting types on.");if(!e.length)throw new n("The types array must include one valid type.");e.forEach(e=>{if("object"==typeof e){if(void 0===e.default_type)throw new TypeError('Parameter "types" (argument 1) contains an object that doesn\'t have a key named "default_value". If an object is present it should have a key name of "default_type" and contain the default type to convert to.');if(i.filter(t=>t===e.default_type).length<1&&"all"!==e.default_type)throw new TypeError(`Invalid data type "${e.default_type}". Allowed data types are: ${r} as well as "all".`)}else if(i.filter(t=>t===e).length<1&&"all"!==e)throw new TypeError(`Invalid data type "${e}". Allowed data types are: ${r} as well as "all".`)}),t[l.allowedTypes.name]=e}),CLIp.ChangeObjectletValue=((e,t,n=!1)=>{if("boolean"!=typeof n)throw new TypeError('Parameter "triggerListeners" (argument 3) is set but not of type "boolean".');if("object"==typeof e[l.type.name]||"property"!==e[l.type.name]&&"method"!==e[l.type.name])throw new TypeError('Parameter "objectlet" (argument 1) is not a valid objectlet or is a commander.');if(e[l.locked.name])return[!1,"locked"];if("property"===e[l.type.name])return"function"==typeof Object.getOwnPropertyDescriptor(e,l.setter.name)&&n?(e[l.setter.name]=t,[!0,t]):(e[l.value.name]=t,[!0,t]);if("function"==typeof Object.getOwnPropertyDescriptor(e,l.setter.name)&&n){const n=[t];return e[l.setter.name]=n,[!0,n[1]]}return[!0,e[l.value.name](t)]}),CLIp.ReturnRoot=(()=>(p(),o)),CLIp.GetFromPath=(async e=>{if(p(),void 0===e)throw new TypeError('Parameter "statement" (argument 1) is not of type "string".');const t=[];let n=!1,r=!1;const i=new c;i.InitializeTokens("\\",'"',":",":","-",">",";","<",">","abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890_");const l=i.Parse(e,!0);await CLIp.CheckCommandLegality(e).catch(()=>{n=!0}),l.forEach(e=>{"objectlet"===e.type?t.push(e.value):"string"===e.type&&(n=!0)});let s=o;return t.forEach((e,n)=>{if(!1===a.strictCommandMode)for(let r in s)r.toLowerCase()===e.toLowerCase()&&(t[n]=r);void 0!==s[t[n]]?(s=s[t[n]],r=!0):r=!1}),!(n||!r)&&s}),CLIp.ReturnMetadata=(e=>{if(p(),void 0===e)throw new TypeError('Parameter "objectlet" (argument 1) is not defined.');if(!e[l.type.name])throw new TypeError('Parameter "objectlet" (argument 1) is not a valid objectlet.');const t={},n=[],r=[];for(let t in l)r.push(t),n.push(e[l[t].name]);return n.forEach((e,n)=>{void 0!==e&&(t[r[n]]=e)}),t}),CLIp.BindListener=((e,t,r)=>{if(p(e,!0),void 0===e)throw new TypeError('Parameter "objectlet" (argument 1) is not defined.');if(void 0===t)throw new TypeError('Parameter "callback" (argument 2) is not defined.');if("[object Object]"!==Object.prototype.toString.call(e))throw new TypeError('Parameter "objectlet" (argument 1) is not an object.');if("function"!=typeof t)throw new TypeError('Parameter "callback" (argument 2) is not a function.');if("property-container"===e[l.type.name]||"main-object"===e[l.type.name])throw new n('Cannot add a listener to an objectlet with a type of "property-container" or "main-object".');if("property"!==e[l.type.name]&&"method"!==e[l.type.name])throw new n("Cannot add a listener to an objectlet without a valid or non-existing type.");if(void 0!==r&&"boolean"!=typeof r)throw new n('Parameter "replaceSameListenerHandler" (argument 3) is set but not of type "boolean".');if(!0!==e[l.allowListeners.name]&&!0===a.strictMode)throw new n("Cannot add a listener to an objectlet not explicitly configured to do so in strict mode.");if("read-only"===e[l.propertyAccessibility.name]&&a.strictMode)throw new n('Cannot add a listener to an objectlet with a property accessibility of "read-only" in strict mode.');void 0===e[l.listeners.name]&&Object.defineProperty(e,l.listeners.name,{value:[],enumerable:!0});let o=!1;if(e[l.listeners.name].forEach(e=>{if(e===t){if(!0===a.strictMode&&!r)throw new n('Cannot declare a listener on the property/method in strict mode because another listener of the same function exists and "replaceSameListenerHandler" is not set to true.');o=!0}}),void 0===Object.getOwnPropertyDescriptor(e,l.setter.name)&&("property"===e[l.type.name]?Object.defineProperty(e,l.setter.name,{enumerable:!0,configurable:!0,set:function(e){const t=this[l.value.name];let n;try{this[l.value.name]=e}catch(e){n=e}this[l.listeners.name].forEach(r=>{r(this[l.type.name],e,t,n)})}}):"method"===e[l.type.name]&&Object.defineProperty(e,l.setter.name,{enumerable:!0,configurable:!0,set:function(e){this[l.listeners.name].forEach(t=>{t(this[l.type.name],e)});const t=this[l.value.name](...e);e.push(t)}})),o&&r){let n=e[l.listeners.name].indexOf(t);return e[l.listeners.name][n]=t,e[l.listeners.name]}return!r&&o?e[l.listeners.name]:(e[l.listeners.name].push(t),e[l.listeners.name])}),CLIp.RemoveListener=((e,t)=>{if(p(e,!0),void 0===e)throw new TypeError('Parameter "objectlet" (argument 1) is not defined.');if(void 0===t)throw new TypeError('Parameter "callback" (argument 2) is not defined.');if("[object Object]"!==Object.prototype.toString.call(e))throw new TypeError('Parameter "objectlet" (argument 1) is not an object.');if("function"!=typeof t)throw new TypeError('Parameter "callback" (argument 2) is not a function.');if("property-container"===e[l.type.name]||"main-object"===e[l.type.name])throw new n('Cannot remove a listener to an objectlet with a type of "property-container" or "main-object".');if("property"!==e[l.type.name]&&"method"!==e[l.type.name])throw new n("Cannot remove a listener to an objectlet without a valid or non-existing type.");if(!0!==e[l.allowListeners.name]&&!0===a.strictMode)throw new n("Cannot remove a listener to an objectlet not explicitly configured to do so in strict mode.");if("read-only"===e[l.propertyAccessibility.name]&&a.strictMode)throw new n('Cannot remove a listener to an objectlet with a property accessibility of "read-only" in strict mode.');if(!e[l.listeners.name])return e[l.listeners.name];let r=e[l.listeners.name].indexOf(t);if(-1===r&&a.strictMode)throw new n("Cannot remove the listener because it doesn't exist!");return-1!==r||a.strictMode?(e[l.listeners.name].splice(r,1),e[l.listeners.name]):e[l.listeners.name]}),CLIp.CheckCommandLegality=(e=>{if(p(),"string"!=typeof e)throw new TypeError('Parameter "command" (argument 1) is not of type "string"');return new Promise((t,n)=>{e.length||t(e);const r=new c;r.InitializeTokens("\\",'"',":",":","-",">",";","<",">","abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890_");const o=r.Parse(e);let a="",i=!1,l=!1,s=!1;o.forEach(e=>{if("unknown_token"!==e.type)if("escaped_char"!==e.type||i)if("pointer"!==e.type||"pointer"!==a)if("pointer"!==e.type||"objectlet"===a||"behavior_block"===a)if("setter"!==e.type||"setter"!==a)if("setter"!==e.type||"objectlet"===a||"behavior_block"===a)if("argument_separator"!==e.type||"argument_separator"!==a)if("behavior_block"!==e.type||"pointer"!==a)if("behavior_block"!==a||"pointer"===e.type||"setter"===e.type||"argument_separator"===e.type)if("open_behavior_block_failure"!==e.type)if("close_behavior_block_failure"!==e.type)if("unclosed_string"!==e.type)if("unclosed_behavior_block"!==e.type)if("behavior_block"!==e.type||i)if("pointer"===e.type&&i)n(new SyntaxError(`Cannot use pointers on the right-hand side of the setter. Column number: ${e.column_numbers[0]}.`));else if("setter"===e.type&&i)n(new SyntaxError(`Cannot use a setter twice. Column number: ${e.column_numbers[0]}.`));else{if("string"!==e.type||i)if("string"===e.type&&i&&s)n(new SyntaxError(`Unexpected raw value after string (cannot combine two ajacent values). Column number: ${e.column_numbers[0]}.`));else if("objectlet"===e.type&&i&&l)n(new SyntaxError(`Unexpected string after raw value (cannot combine two ajacent values). Column number: ${e.column_numbers[0]}.`));else if("string"===e.type&&i)l=!0;else if("objectlet"===e.type&&i)s=!0;else if("behavior_block"===e.type){const t=e.value.split("");t.shift(),t.pop();let r=e.column_numbers[0]+1,o=!1,a=!1;if(t.forEach(e=>{if('"'===e&&(a=!a),":"!==e||o||a){if(":"===e&&o&&!a)return void n(new SyntaxError(`Unexpected token ":". Column number: ${r}.`))}else o=!0;++r}),a)return void n(new SyntaxError(`Unclosed string inside of behavior block. Column number: ${e.column_numbers[0]}.`));if(t.length<1)return void n(new SyntaxError(`Cannot have empty behavior block. Column number: ${e.column_numbers[0]}.`))}else"setter"===e.type&&(i=!0);else n(new SyntaxError(`Cannot use strings on the left-hand side of the setter. Column number: ${e.column_numbers[0]}.`));a=e.type}else n(new SyntaxError(`Cannot use behavior blocks on left-hand side of setter. Column number: ${e.column_numbers[0]}.`));else n(new SyntaxError(`Unclosed behavior block. Column number: ${e.column_numbers[0]}.`));else n(new SyntaxError(`Unclosed string. Column number: ${e.column_numbers[0]}.`));else n(new SyntaxError(`Unexpected type declaration closing operator. Column number: ${e.column_numbers[0]}.`));else n(new SyntaxError(`Unexpected behavior block opening operator. Column number: ${e.column_numbers[0]}.`));else n(new SyntaxError(`Unexpected token "${e.value}", expecting an argument separator (or if it's a property - EOS (end of statement)) after behavior block. Column number: ${e.column_numbers[0]}.`));else n(new SyntaxError(`Unexpected behavior block, expected objectlet. Column number: ${e.column_numbers[0]}.`));else n(new SyntaxError(`Unexpected argument separator, expected value. Column number: ${e.column_numbers[0]}.`));else n(new SyntaxError(`Unexpected token before setter, expecting objectlet but got ${a} instead. Column number: ${e.column_numbers[0]}.`));else n(new SyntaxError(`Unexpected setter, expected value. Column number: ${e.column_numbers[0]}.`));else n(new SyntaxError(`Unexpected token before pointer, expecting objectlet but got ${a} instead. Column number: ${e.column_numbers[0]}.`));else n(new SyntaxError(`Unexpected pointer, expecting objectlet. Column number: ${e.column_numbers[0]}.`));else n(new SyntaxError(`Unexpected escape character on the left-hand side of the setter. Column number: ${e.column_numbers[0]}.`));else n(new SyntaxError(`Unknown token "${e.value}". Column number: ${e.column_numbers[0]}.`))}),"setter"!==o[o.length-1].type?"pointer"!==o[o.length-1].type?t(e):n(new SyntaxError(`Expected an objectlet after pointer but found EOS (end of statement) instead. Column number: ${o[o.length-1].column_numbers[0]}.`)):n(new SyntaxError(`Expected a value after setter but found EOS (end of statement) instead.Column number: ${o[o.length-1].column_numbers[0]}.`))})}),CLIp.GetRelevantCommands=((e,t,n,r,i=!0)=>{if(p(),void 0===e)throw new TypeError('Parameter "command" (argument 1) is not defined.');if("string"!=typeof e)throw new TypeError('Parameter "command" (argument 1) is not a valid string.');if(void 0!==t&&"boolean"!=typeof t)throw new TypeError('Parameter "properSyntaxEnforced" (argument 2) is set but is not of type "number".');if(void 0!==n&&"number"!=typeof n)throw new TypeError('Parameter "trimNum" (argument 3) is set but  not of type "number".');let m=!1;if("number"==typeof r&&(m=!0),e.length<1)return Promise.resolve([1,[]]);const u=e=>new Promise((t,n)=>{const p=[],u=new c;u.InitializeTokens("\\",'"',":",":","-",">",";","<",">","abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890_");const d=u.Parse(e);let y="";d.forEach(e=>{if("objectlet"===e.type)p.push(e.value);else if("unknown_token"===e.type)(":"!==e.value||":"===e.value&&"pointer"===y)&&t([]);else{if("escaped_char"===e.type)return void t([]);"setter"===e.type&&t([])}y=e.type});const h=(e,t)=>{let n=0,o=0;if("object"!=typeof e)throw new TypeError('Parameter "obj" (argument 1) is not of type "object".');return new Promise((a,s)=>{let p=[];const c=(e,t,s)=>{if("main-object"!==e[l.type.name]&&"property-container"!==e[l.type.name]&&"clip-help"!==e[l.type.name]&&!i)return p.push(t),void a(p);"main-object"!==e[l.type.name]&&"property-container"!==e[l.type.name]&&"clip-help"!==e[l.type.name]&&i&&p.push(t);for(let u in e)if("[object Object]"===Object.prototype.toString.call(e[u])&&0===n){if(m&&s.split("::").length>=r&&0===n)for(const t in e[u])++n;m&&s.split("::").length>=r?1!==r?c(e[u],t+"::"+u,s+"::"+u):p.push(t+"::"+u):c(e[u],t+"::"+u,s+"::"+u)}else{if(!i&&l.MetaTypeMatches(u,e[u]))continue;m&&s.split("::").length>r&&n>0?(p.push(t+"::"+u),++o>=n&&a(p)):(p.push(t+"::"+u),a(p))}};c(e,t,"")})};let f=o;p.forEach((n,r)=>{if(r>=p.length-1)if(void 0===f[n])if(a.strictCommandMode){let e=new RegExp("^"+s(n)),r=[];e:for(let t in f){if(!i)for(const e in l)if(t===l[e].name)continue e;e.test(t)&&r.push(t)}let o=[];r.forEach(e=>{for(let t in l)if(l[t].name===e&&i)return void o.push(Array.from(p).splice(0,p.length-1).join("::")+"::"+e);p.length<2?h(f[e],p.map(e=>e).splice(0,p.length-1).join("::")+e).then(e=>{e.forEach(e=>{o.push(e)})}):h(f[e],p.map(e=>e).splice(0,p.length-1).join("::")+"::"+e).then(e=>{e.forEach(e=>{o.push(e)})})}),t(o)}else{let e=new RegExp("^"+s(n),"i"),r=[];e:for(let t in f){if(!i)for(const e in l)if(t===l[e].name)continue e;e.test(t)&&r.push(t)}let o=[];r.forEach(e=>{for(let t in l)if(l[t].name===e&&i)return void o.push(p.map(e=>e).splice(0,p.length-1).join("::")+"::"+e);p.length<2?h(f[e],Array.from(p).splice(0,p.length-1).join("::")+e).then(e=>{e.forEach(e=>{o.push(e)})}):h(f[e],p.map(e=>e).splice(0,p.length-1).join("::")+"::"+e).then(e=>{e.forEach(e=>{o.push(e)})})}),t(o)}else{if("object"!=typeof f[n])return void t([]);h(f[n],p.join("::")).then(r=>{1===r.length&&f[n][l.value.name]?t([e]):t(r)})}else{let e=!1;for(let t in f)t.toLowerCase()===n.toLowerCase()&&(f=f[t],p[r]=t,e=!0);e||t([])}})});return t?new Promise((t,r)=>{CLIp.CheckCommandLegality(e).then(e=>{u(e).then(e=>{Array.isArray(e)?n?(e.splice(n),t([1,e])):t([1,e]):t([0,e])})}).catch(e=>{r([0,e])})}):new Promise((t,r)=>u(e).then(e=>{Array.isArray(e)?n?(e.splice(n),t([1,e])):t([1,e]):t([0,t])}).catch(e=>{r([0,e])}))}),CLIp.ParseInput=(n=>{if(p(),void 0===n)throw new TypeError('Parameter "command" (argument 1) is not defined.');if(n.length<1)return"";return new Promise((r,s)=>{CLIp.CheckCommandLegality(n).then(e=>(e=>new Promise((n,r)=>{const i=[],l=[];let s=!1,p=0;const m=new c;if(m.InitializeTokens("\\",'"',":",":","-",">",";","<",">","abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890_"),m.Parse(e).forEach(e=>{"objectlet"!==e.type||s?"setter"===e.type&&(s=!0,p=e.column_numbers[0]):(i.push(e.value),l.push(e.column_numbers[0]))}),!s&&"writeOnly"===a.executionMode.value)return void r(new t(`Cannot omit setter operator in  "write-only" mode. Column number: ${p}.`));if(s&&"readOnly"===a.executionMode.value)return void r(new t(`Cannot use setter operator in "read-only" mode. Column number: ${p}.`));let u=o;i.forEach((e,n)=>{if(!1===a.strictCommandMode)for(let t in u)t.toLowerCase()===e.toLowerCase()&&(i[n]=t);void 0!==u[i[n]]?u=u[i[n]]:r(new t(`An undefined objectlet was found: "${e}". Column number: ${l[n]}.`))}),n([e,u,i[i.length-1]])}))(e)).then(([e,n,r])=>((e,n,r)=>new Promise((o,a)=>{const s=new c;s.InitializeTokens("\\",'"',":",":","-",">",";","<",">","abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890_");const p=s.Parse(e,!1,!0),m=p.length>0;let u=!1;"main-object"!==n[l.type.name]&&"property-container"!==n[l.type.name]&&"clip-help"!==n[l.type.name]||!m||a(new t("Cannot change the value of or execute a main property container/property container."));let d=!1;for(let e in l)l[e].name===r&&(d=!0);if(void 0!==n[l.type.name]||d)if(u="method"!==n[l.type.name]){let s="",c="string";const d=n[l.allowedTypes.name]&&Array.isArray(n[l.allowedTypes.name])?n[l.allowedTypes.name].filter(e=>e.default_type):[];d.length>0&&(c=d[0].default_type),p.forEach(e=>{if("objectlet"===e.type||"string"===e.type||"escaped_char"===e.type)s+=e.value;else if("argument_separator"===e.type)a(new t(`Cannot use argument separators on a property. Column number: ${e.column_numbers[0]}.`));else if("behavior_block"===e.type){let n="",r="",o=!0,l=!1,s=e.value.split("");s.shift(),s.pop(),s.forEach(e=>{'"'===e?l=!l:o?":"!==e||l?n+=e:o=!1:o||(r+=e)}),"type"!==n&&a(new t(`Unknown behavior block behavior "${n}". Column number: ${e.column_numbers[0]}.`)),i.filter(e=>e===r).length<1&&a(new t(`Unsupported type "${r}". Column number: ${e.column_numbers[0]}.`)),c=r}}),o([e,n,s,c,u,!m,r])}else{const l=[],s=[];let c=!1;if(p.forEach(e=>{if("objectlet"!==e.type&&"string"!==e.type||c)if("objectlet"!==e.type&&"string"!==e.type||!c){if("escaped_char"===e.type)l[l.length-1]+=e.value,c=!0;else if("argument_separator"===e.type)c=!1;else if("behavior_block"===e.type){let n="",r="",o=!0,l=!1,p=e.value.split("");p.shift(),p.pop(),p.forEach(e=>{'"'===e?l=!l:o?":"!==e||l?n+=e:o=!1:o||(r+=e)}),"type"!==n&&a(new t(`Unknown behavior block behavior "${n}". Column number: ${e.column_numbers[0]}.`)),i.filter(e=>e===r).length<1&&a(new t(`Unsupported type "${r}". Column number: ${e.column_numbers[0]}.`)),s.push(r)}}else l[l.length-1]+=e.value,c=!1;else l.push(e.value)}),s.length<1)for(let e=0,t=l.length;e<t;++e)s.push("string");o([e,n,l,s,u,!m,r])}else a(new t(`Target objectlet ${r}'s type cannot be determined ("property","method", "property-container" or "main-object") meaning that it is not changable (Main objects and property-containers are not changable).`))}))(e,n,r)).then(([n,r,o,i,s,p,m])=>((n,r,o,i,s,p,m)=>new Promise((n,c)=>{if(!r[l.locked.name]||p||"property"!==r[l.type.name])try{const t=()=>{if(i)if("infer"===i)if(r[l.allowedValues.name].length>1){let t=0;r[l.allowedValues.name].filter((e,n)=>{e[0].toLowerCase()===o.toLowerCase()&&(t=n)});const n=r[l.allowedValues.name][t][1];if(n.forEach(e=>{"null"===e?o=null:"undefined"===e?o=void 0:"NaN"===e?o=NaN:Number.isNaN(Number(e))||(o=Number(o))}),"string"==typeof o&&!n.includes("string"))throw c(new e("Cannot convert value's type to an allowed type - the type of the value does not match any of the allowed types for the allowed value.")),""}else r[l.allowedTypes.name].length>1?r[l.allowedTypes.name].forEach(e=>{"null"===e?o=null:"undefined"===e?o=void 0:"NaN"===e?o=NaN:Number.isNaN(Number(e))||(o=Number(o))}):"null"===o?o=null:"undefined"===o?o=void 0:"NaN"===o?o=NaN:Number.isNaN(Number(o))||(o=Number(o));else if("null"===i)o=null;else if("undefined"===i)o=void 0;else if("NaN"===i)o=NaN;else if("number"===i){if(Number.isNaN(Number(o)))throw c(new e(`Attempt to convert a "${o}" to a number failed. "${o}" is not a valid number.`)),"";o=Number(o)}else"string"===i&&(o=o.toString())};let u=!1;for(let e in l)l[e].name===m&&(u=!0);let d=r[l.type.name];if(d="method"===d?"Executable Command":"property"===d?r[l.propertyAccessibility.name]&&"read-only"===r[l.propertyAccessibility.name]?"Read-Only Value":"Changable Value":"main-object"===d?"Main Property Container":"property-container"===d?"Property Container":"clip-help"===d?"Official CLIp help commands":"Unknown",p&&!u)n("Property Container"===d||"Main Property Container"===d||"Official CLIp help commands"===d?[d,"object",JSON.stringify(r)]:[d,typeof r[l.value.name],r[l.value.name]]);else if(u){if(!p)throw new e("Cannot change values of metadata.");n(["Objectlet Metadata",typeof r,r])}else{if(r[l.allowedTypes.name]&&r[l.allowedTypes.name].length>0){const t=r[l.allowedTypes.name];if(t.filter(e=>e===i).length<1&&!t.includes("all")){const t=r[l.allowedTypes.name];return t.forEach((e,n)=>{e.default_type&&t.splice(n,1)}),void c(new e(`Cannot set property's value to "${o}" with type "${i}" because it violates the allowed types for the property ("${t}").`))}}if(r[l.allowedValues.name]&&r[l.allowedValues.name].length>0){if(r[l.allowedValues.name].filter(e=>!0===a.strictCommandMode?e[0]===o:e[0].toLowerCase()===o.toLowerCase()).length<1){const t=r[l.allowedValues.name].reduce((e,t)=>""===e?t[0]:e+`, ${t[0]}`,"");return void c(new e(`Cannot set property's value to "${o}" because it violates the allowed values for the property ("${t}").`))}let t=0;r[l.allowedValues.name].filter((e,n)=>{e[0].toLowerCase()===o.toLowerCase()&&(t=n)});const n=r[l.allowedValues.name][t][1];if(n.filter(e=>e===i).length<1&&!n.includes("all")){const t=n.join(", ");return void c(new e(`Cannot set property's value to "${o}" with type "${i}" because it violates the allowed types for the specific value ("${t}").`))}}let p;if(void 0!==Object.getOwnPropertyDescriptor(r,l.setter.name))if(s){if(r[l.propertyAccessibility.name]&&"read-only"===r[l.propertyAccessibility.name])return void c(new e("Cannot change the property's value because it is read-only."));t(),r[l.setter.name]=o,p=r[l.value.name]}else{const e=[...o];r[l.setter.name]=e,p=e[e.length-1]}else if(s){if(r[l.propertyAccessibility.name]&&"read-only"===r[l.propertyAccessibility.name])return void c(new e("Cannot change the property because it is read-only."));t(),p=r[l.value.name]=o}else{const t=t=>{i[t]&&("infer"===i[t]?"null"===o[t]?o[t]=null:"undefined"===o[t]?o[t]=void 0:"NaN"===o?o[t]=NaN:Number.isNaN(Number(o))||(o[t]=Number(o)):"null"===i[t]?o[t]=null:"undefined"===i[t]?o[t]=void 0:"NaN"===i[t]?o[t]=NaN:"number"===i[t]?Number.isNaN(Number(o[t]))?c(new e(`Attempt to convert a "${o[t]}" to a number failed. "${o[t]}" is not a valid number.`)):o[t]=Number(o[t]):"string"===i[t]&&(o[t]=o[t].toString()))};o.length>1?o.forEach((e,n)=>{t(n)}):i.length>1&&i.forEach((e,n)=>{t(n)}),p=r[l.value.name](...o)}n([d,typeof p,p])}}catch(e){c(e)}else c(new t("Cannot change the value of a locked objectlet."))}))(0,r,o,i,s,p,m)).then(e=>{r(e)}).catch(e=>{s(e)})})})})();
